#![allow(unused)]
#![feature(concat_idents)]
pub mod data;
use std::convert::AsRef;
use std::cell::{Cell, RefCell};
use std::rc::Rc;
use wasm_bindgen::prelude::*;
use wasm_bindgen::JsCast;
use web_sys::{CanvasRenderingContext2d, EventTarget, HtmlCanvasElement};

use data::{Point, Points};


///////////////////////////////////////////////////////////////////////////////
// HELPERS
///////////////////////////////////////////////////////////////////////////////

#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(js_namespace = console, js_name = log)]
    fn log_str(s: &str);
}

macro_rules! console_log {
    // Note that this is using the `log` function imported above during
    // `bare_bones`
    ($($t:tt)*) => {
        unsafe {
            log_str(&format_args!($($t)*).to_string())
        }
    }
}

impl AsRef<web_sys::EventTarget> for Canvas {
    fn as_ref(&self) -> &web_sys::EventTarget {
        &self.canvas
    }
}

macro_rules! register_callback {
    ($target:expr, $event_name:expr, $callback:expr) => {{
        let closure = Closure::wrap(Box::new({
            $callback
        }) as Box<dyn FnMut(_)>);
        {
            $target.add_event_listener_with_callback(
                $event_name,
                closure.as_ref().unchecked_ref()
            )?
        }
        closure.forget();
    }};
}

macro_rules! cloned {
    ($ident:ident, $func:expr) => {{
        let $ident = $ident.clone();
        $func
    }};
}

///////////////////////////////////////////////////////////////////////////////
// HELPER TYPES
///////////////////////////////////////////////////////////////////////////////

#[derive(Debug, Clone, Copy, Default)]
pub struct BoundingBox {
    top: f64,
    left: f64,
    width: f64,
    height: f64,
}



///////////////////////////////////////////////////////////////////////////////
// ROOT CANVAS
///////////////////////////////////////////////////////////////////////////////

#[derive(Clone)]
pub struct Canvas {
    canvas: HtmlCanvasElement,
    ctx: CanvasRenderingContext2d,
    // CANVAS STATE
    pressed: bool,
    window_resized: bool,
    // CANVAS METADATA
    dpi: f64,
    rect: BoundingBox,
    // CANVAS PAYLOAD
    points: Points,
}

impl Canvas {
    ///////////////////////////////////////////////////////////////////////////
    // CREATE SELF
    ///////////////////////////////////////////////////////////////////////////
    fn new() -> Result<Self, JsValue> {
        ///////////////////////////////////////////////////////////////////////
        // SETUP
        ///////////////////////////////////////////////////////////////////////
        let window = web_sys::window().unwrap();
        let document = window.document().unwrap();
        let canvas = document
            .create_element("canvas")?
            .dyn_into::<web_sys::HtmlCanvasElement>()?;
        document.body().unwrap().append_child(&canvas)?;
        let context = canvas
            .get_context("2d")?
            .unwrap()
            .dyn_into::<web_sys::CanvasRenderingContext2d>()?;
        // let context = Rc::new(context);
        ///////////////////////////////////////////////////////////////////////
        // OTHER METADATA
        ///////////////////////////////////////////////////////////////////////
        let dpi = window.device_pixel_ratio();
        let rect: web_sys::DomRect = canvas.get_bounding_client_rect();
        let width = rect.width() * dpi;
        let height = rect.height() * dpi;
        ///////////////////////////////////////////////////////////////////////
        // DONE
        ///////////////////////////////////////////////////////////////////////
        Ok(Canvas{
            canvas,
            ctx: context,
            pressed: Default::default(),
            window_resized: Default::default(),
            dpi: Default::default(),
            rect: Default::default(),
            points: Default::default(),
        })
    }
    ///////////////////////////////////////////////////////////////////////////
    // INTERNAL HELPERS
    ///////////////////////////////////////////////////////////////////////////
    fn setup(&mut self) {
        self.update_resolution();
        // self.ctx.set_stroke_style(
        //     &wasm_bindgen::JsValue::from_str("hsl(0deg 0% 69% / 77%)")
        // );
        self.ctx.set_line_width(20.0);
    }
    fn update_resolution(&mut self) {
        let window = web_sys::window().unwrap();
        let dpi = window.device_pixel_ratio();
        let rect: web_sys::DomRect = self.canvas.get_bounding_client_rect();
        let width = rect.width() * dpi;
        let height = rect.height() * dpi;
        // UPDATE DOM
        self.canvas.set_width(width as u32);
        self.canvas.set_height(height as u32);
        // UPDATE SELF
        self.dpi = dpi;
        self.rect = BoundingBox {
            top: rect.top(),
            left: rect.left(),
            width,
            height,
        };
    }
    fn get_current_pos(&self, event: &web_sys::MouseEvent) -> Point {
        let window = web_sys::window().unwrap();
        let rect = self.rect;
        let dpi = self.dpi;
        let x = {
            (event.client_x() as f64 - rect.left)
                * dpi
        };
        let y = {
            (event.client_y() as f64 - rect.top)
                * dpi
        };
        Point::new(x, y)
    }
    fn move_to(&mut self, point: Point) {
        let [x, y] = point.into();
        self.ctx.move_to(x, y)
    }
    fn line_to(&mut self, point: Point) {
        let [x, y] = point.into();
        self.ctx.line_to(x, y)
    }
    fn stroke(&mut self) {
        self.ctx.stroke()
    }
    fn begin_path(&mut self) {
        self.ctx.begin_path()
    }
    ///////////////////////////////////////////////////////////////////////////
    // EVENT HANDLERS
    ///////////////////////////////////////////////////////////////////////////
    fn on_mouse_down(&mut self, event: web_sys::MouseEvent) {
        self.pressed = true;
        let point = self.get_current_pos(&event);
        self.points.begin_new_segment(point);
    }
    fn on_mouse_up(&mut self, event: web_sys::MouseEvent) {
        self.pressed = false;
        let point = self.get_current_pos(&event);
        self.points.add_point(point);
    }
    fn on_mouse_move(&mut self, event: web_sys::MouseEvent) {
        if self.pressed {
            let point = self.get_current_pos(&event);
            self.points.add_point(point);
        }
    }
}





#[wasm_bindgen(start)]
pub fn start() -> Result<(), JsValue> {
    ///////////////////////////////////////////////////////////////////////////
    // SYSTEM INIT
    ///////////////////////////////////////////////////////////////////////////
    console_error_panic_hook::set_once();
    ///////////////////////////////////////////////////////////////////////////
    // SETUP CANVAS
    ///////////////////////////////////////////////////////////////////////////
    let mut canvas: Rc<RefCell<Canvas>> = Rc::new(RefCell::new(Canvas::new()?));
    canvas.borrow_mut().setup();
    ///////////////////////////////////////////////////////////////////////////
    // REGISTER EVENET HANDLERS
    ///////////////////////////////////////////////////////////////////////////
    register_callback!(
        &canvas.borrow().canvas,
        "mousedown",
        cloned!(canvas, move |event: web_sys::MouseEvent| {
            canvas.borrow_mut().on_mouse_down(event)
        })
    );
    register_callback!(
        &canvas.borrow().canvas,
        "mouseup",
        cloned!(canvas, move |event: web_sys::MouseEvent| {
            canvas.borrow_mut().on_mouse_up(event)
        })
    );
    register_callback!(
        &canvas.borrow().canvas,
        "mousemove",
        cloned!(canvas, move |event: web_sys::MouseEvent| {
            canvas.borrow_mut().on_mouse_move(event)
        })
    );
    register_callback!(
        &web_sys::window().unwrap(),
        "resize",
        cloned!(canvas, move |event: web_sys::UiEvent| {
            canvas.borrow_mut().update_resolution();
        })
    );

    Ok(())
}
